\chapter{Background}

\epigraph{Sometimes the journey of a thousand steps begins by learning to walk}{Bhuvy}

\section{Systems Architecture}

This section is a short review of System Architecture topics that you'll need for System Programming.

\subsection{Assembly}

What is assembly? Assembly is the lowest that you'll get to machine language without writing 1's and 0's.
Each computer has an architecture, and that architecture has an associated assembly language.
Each assembly command has a 1:1 mapping to a set of 1's and 0's that tell the computer exactly what to do.
For example the following in the widely used x86 Assembly language add one to the memory address 20.

\begin{verbatim}
add BYTE PTR [0x20], 1
\end{verbatim}

Why do we mention this? Because it is important that although you are going to be doing most of this class in C
That this is what the code is translated into.
Serious implications arise for race conditions and atomic operations.

\subsection{Atomic Operations}

An operation is atomic if no other processor should interrupt it. Take for example the above assembly code to add one to a register.
In the architecture, it may actually have a few different steps on the circuit.
The operation may start by fetching the value of the memory from the stick of ram, then storing it in the cache or a register, and then finally writing back.
The problem comes in if two processors try to do it at the same time.
The two processors could (at the same time) copy the value of the memory address, add one, and store the same result back.
Resulting in the value only being incremented once.
That is why we have a special set of instructions on modern systems called atomic operations.
If an instruction is atomic, it makes sure that only one processor or thread performs any intermediate step at a time.
With x86 this is done by the \keyword{lock} prefix.

\begin{verbatim}
lock add BYTE PTR [0x20], 1
\end{verbatim}

Why don't we do this for everything?
It makes commands slower! If every time a computer does something it has to make sure that the other cores or processors aren't doing anything, it'll be much slower.
Most of the time we differentiate these.

\subsection{Caching}

Ah yes Caching.
One of computer science's greatest problems.
Caching that we are referring is processor caching.
Whenever you do a memory access if the particular address is already in the cache then the processor will perform the operation on the cache (such as adding) and update the actual memory later because updating memory is slow.
If it isn't, the processor requests a chunk of memory from the the memory chip and stores it in cache, kicking out the least recently used page (roughly).
This is done because the processor cache is roughly ten times faster to reach than the memory in terms of time.
Naturally this leads to problems because there are two different copies of the same value.
This isn't a class about caching, just know how this could impact your code.

\subsection{Interrupts}

Interrupts are a very important part of system programming.
An interrupt is internally an electrical signal that is delivered to the processor when something happens -- this is hardware interrupt.
Then the hardware decides if this is something that it should handle (i.e. handling keyboard or mouse input for older keyboard and mouses) or it should pass to the operating system.
The operating system then decides if this is something that it should handle (i.e. paging a memory table from disk) or something the application should handle (i.e. a SEGFAULT).
The application then decides if it is an error (SEGFAULT) or not (SIGPIPE for example) and reports to the user.
Applications can also send signals to the kernel and to the hardware as well.

An important application of this is this is how system calls are served!
There is a well established set of registers that the arguments go in according to the kernel as well as a system call ``number'' again defined by the kernel.
Then the operating system triggers an interrupt which the kernel catches and serves the system call.

\subsection{Extra: Out of order instructions}

For those of you who have and haven't taken the systems architecture course, you may not have heard about out of order instruction execution.
Out of order execution is an amazing development by processors recently.
Processors now instead of executing a sequence of instructions (let's say assigning a variable and then another variable) execute instructions before the current one is done.
This is because modern processors spend a lot of time waiting for memory accesses and other I/O driven applications.
This means that a processor while it is waiting for an operation to complete will execute the next few operations.
If any of the operations would possibly alter the previous operation or there is a barrier, the processor will not reorder the instructions.

This naturally has allowed CPUs to become more energy efficient while executing more instructions in real time but naturally comes with security risks and more complex architectures.
Where system programmers are worried is that (this is discussed in later chapters) operationg with mutex locks among threads are out of order -- meaning that a software implementation of a mutex will not work without copious memory barriers.
Basically, the programmer has to adopt the mental model of updates may not be seen among a series of threads without a barrier on modern processors.

One of the most prominent bugs with respect to this is Spectre.
Spectre is a bug where instructions that otherwise wouldn't be executed are due to out of order instruction execution.
Here is an example
\begin{lstlisting}[language=C]
  char *a[10];
  for (int i = 10; i != 1; --i) {
    a[i] = calloc(1, 1);
  }
  a[0] = 0xCAFE;
  int val;
  int j = 10; // This will be in a register
  int i = 10; // This will be in main memory
  for (int i = 10; i != 0; --i, --j) {
    if (i) {
        val = *a[j];
    }
  }
\end{lstlisting}

Let's anaylze this code.
The first loop allocates 9 elements through a valid malloc.
The last element is \keyword{0xCAFE}, meaning a dereference should result in a segfault.
For the first 9 iterations, the branch is taken and the second branch in the dereference (the question mark) also returns the first value.
The interesting part happens in the last iteration.
The resulting behavior of the program is to skip the last iteration and \keyword{val} never gets asisgned the last previous value.

But under the right compilation conditions and compiler flags, the instructions will get out of order executed. The processor thinks that the branch will be taken -- it has been taken in the last 9 iterations.
As such the processor will load that code up.
Due to out of order instruction execution, while the value of i is being fetched from memory -- we have to force it not to be in a register -- the processor will try to dereference that address.
Naturally that should result in a segfault, but since the address was never logically reached by the program the result is just discarded.

Now here is the trick.
Even though the value of the calculation would've resulted in a segfault, the bug doesn't clear the cache that refers to the physical memory where 0xCAFE is located (this not an exact explanation, but essentially how it works)
Since it is still in the cache, if you again trick the processor to read form the cache using \keyword{val} then you will read a memory value that you wouldn't be able to read normally.
This includes important information like passwords, payment info etc etc.

\subsection{Optional: Hyperthreading}

Hyperthreading is a new technology and is in no way shape or form multithreading. Hyperthreading is allowing one physical core appear as many virtual cores to the operating system
The operating system can then schedule processes on these virtual cores and one core will execute them.
Each core interleaves processes.
While the core is waiting for one memory access to complete, it may perform a few instructions of another process.
The overall result is more instructions executed in a shorter time.
This is also potentially means that you can divide the number of cores you need to power smaller devices.

There be dragons here though.
With hyperthreading, you must be wary of optimizations.
A famous hyperthreading bug that caused programs to crash if at least two processes was scheduled on a physical core, using specific registers, in a tight loop.
The actual problem is better explained through an architecture lens.
But, the actual application was found through systems programmers working on OCaml's mainline.
\url{http://gallium.inria.fr/blog/intel-skylake-bug/}

\section{Debugging and Environments}

I'm going to tell you a secret about this course: it is about working smarter \textit{not} harder. The course can be time consuming but the reason that so many people see it as such (and why so many student's don't see it as such) is the relative familiarity of people with their tools. Let's go through some of the common tools that you'll be working on and need to be familiar with.

\subsection{ssh}

\texttt{ssh} is short for the Secure Shell. It is a network protocol that allows you to spawn a shell on a remote machine.
Most of the times in this class you will need to ssh into your VM like this

\begin{verbatim}
> ssh netid@sem-cs241-VM.cs.illinois.edu
\end{verbatim}

If you don't want to type your password out every time, you can generate an ssh key that uniquely identifies your machine. If you already have a key pair, you can skip to the copy id stage.

\begin{verbatim}
  > ssh-keygen -t rsa -b 4096
  # Do whatever keygen tells you
  # Don't feel like you need a passcode if your login password is secure
  > ssh-copy-id netid@sem-cs241-VM.cs.illinois.edu
  # Enter your password for maybe the final time
  > ssh  netid@sem-cs241-VM.cs.illinois.edu
\end{verbatim}

If you still think that that is too much typing, you can always alias hosts. You may need to restart your VM or reload sshd for this to take effect. The config file is available on linux and mac distros. For windows you'll have to use the Windows Linux Subsystem or configure any aliases in PuTTY
\begin{verbatim}
> cat ~/.ssh/config
Host vm
  User          netid
  HostName      sem-cs241-VM.cs.illinois.edu
> ssh vm
\end{verbatim}

\subsection{git}

What is `git`? Git is a version control system. What that means is git stores the entire history of a directory. We refer to the directory as a repository. So what do you need to know is a few things. First, create your repository with the repo creator. If you haven't already signed into enterprise github, make sure to do so otherwise your repository won't be created for you. After that, that means your repository is created on the server. Git is a decentralized version control system, meaning that you'll need to get a repository onto your VM. We can do this with a clone. Whatever you do, \textbf{do not go through the README.md tutorial}.

\begin{verbatim}
$ git clone https://github-dev.cs.illinois.edu/cs241-fa18/<netid>.git
\end{verbatim}

This will create a local repository. The workflow is you make a change on your local repository, add the changes to a current commit, actually commit, and push the changes to the server.

\begin{verbatim}
$ # edit the file, maybe using vim
$ git add <file>
$ git commit -m "Committing my file"
$ git push origin master
\end{verbatim}

Now to explain git well, you need to understand that git for our purposes will look like a linked list.
You will always be at the head of master, and you will do the edit-add-commit-push loop. We have a separate branch on github that we push feedback to under a specific branch which you can view on github website. The markdown file will have information on the test cases and results (like standard out).

Every so often git can break. Here are a list of commands you probably won't need to fix your repo

\begin{enumerate}
\item git-cherry-pick
\item git-pack
\item git-gc
\item git-clean
\item git-rebase
\item git-stash/git-apply/git-pop
\item git-branch
\end{enumerate}

In addition if you are currently on a branch, and you don't see either

\begin{verbatim}
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
\end{verbatim}

or

\begin{verbatim}
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   <FILE>
        ...

no changes added to commit (use "git add" and/or "git commit -a")
\end{verbatim}

And something like

\begin{verbatim}
$ git status
HEAD detached at 4bc4426
nothing to commit, working directory clean
\end{verbatim}

Don't panic, but your repository may be in an unworkable state. If you aren't nearing a deadline, come in to office hours or ask your question on Piazza, and we'd be happy to help. In an emergency scenario, delete your repository and re-clone (you'll have to add the \texttt{release} as above). \textbf{This will lose any local uncommitted changes. Make sure to copy any files you were working on outside the directory, remove and copy them back in}


\subsection{Editors}

Some people take this as an opportunity to learn a new editor, others not so much. The first part is those of you who want to learn a new editor. In the editor war that spans decades, we have come to the battle of vim vs emacs.

Vim is a text editor and unix-like utility. You enter vim by typing \texttt{vim [file]}. This takes you into the editor. You start off in normal mode. In this mode you can move around with many keys with the most common ones being \texttt{jklh}. To exit vim from this mode, you need to type \texttt{:q} which quits. If you have any unsaved edits, you must either save them \texttt{:w}, save and quit \texttt{:wq}, or discard changes \texttt{:q!}. To make edits you can either type \texttt{i} to change you into insert mode or \texttt{a} to change to insert mode \textbf{a}fter the cursor. This is the very basics when it comes to vim

Emacs is more of a way of life, and I don't mean that figuratively. A lot people when they switch to the emacs environment realize that it is a powerful operating system lacking a decent text editor. This means emacs can house a terminal, gdb session, ssh session, code and a whole lot more. It would not be fitting any other way to introduce you the gnu-emacs any other way than the gnu-docs \url{https://www.gnu.org/software/emacs/tour/}. Just note that emacs is \textit{insanely} powerful. You can do almost anything with it. There are a fair number of students who like the IDE-aspect of other programming languages, just know you can set up emacs to be an IDE, but you have to learn a bit of lisp \url{http://martinsosic.com/development/emacs/2017/12/09/emacs-cpp-ide.html}.

Then there are those of you who like to use your own editors. That is completely fine.
For this we require sshfs which has ports on many different machines
\begin{enumerate}
\item Windows \url{https://github.com/billziss-gh/sshfs-win}
\item Mac \url{https://github.com/osxfuse/osxfuse/wiki/SSHFS}
\item Linux \url{https://help.ubuntu.com/community/SSHFS}
\end{enumerate}
At that point the files on your VM are synced with the files on your machine and edits can be made and will be sync'ed

At the time of writing, Bhuvy (That's me!) really likes to use spacemacs \url{http://spacemacs.org/} which marries both vim and emacs and both of their difficulties. I'll give my soapbox for why I like it, but be warned that if you are starting from absolutely no vim or emacs experience the learning curve along with this course may be too much.
\begin{enumerate}
\item Extensible. Spacemacs has a clean design written in lisp. There are 100s of packages ready to be installed by editing your spacemacs config and reloading that do everything from syntax checking, automatic static analyzing, etc etc.
\item Most of the good parts from vim and emacs. Emacs is really good at doing everything by being a fast editor. Vim is really good at making fast edits and moving around. Spacemacs is the best of both worlds allowing vim keybindings with all the emacs goodness underneath.
\item Lots of preconfiguration done. As opposed with a fresh emacs install, a lot of the configurations with language and projects are done for you like neotree, helm, various language layers. All they you have to do is navigate neotree to the base of your project and emacs will turn into an IDE for that programming language.
\end{enumerate}

\subsection{clean code}

Make your code modular using helper functions. If there is a repeated task (getting the pointers to contiguous blocks in the malloc MP, for example), make them helper functions. And make sure each function does one thing very well, so that you don't have to debug twice.
Let's say that we are doing selection sort by finding the minimum element each iteration like so,

\begin{lstlisting}[language=C]
void selection_sort(int *a, long len){
     for(long i = len-1; i > 0; --i){
         long max_index = i;
         for(long j = len-1; j >= 0; --j){
             if(a[max_index] < a[j]){
                  max_index = j;
             }
         }
         int temp = a[i];
         a[i] = a[max_index];
         a[max_index] = temp;
     }

}
\end{lstlisting}

Many can see the bug in the code, but it can help to refactor the above
method into

\begin{lstlisting}[language=C]
long max_index(int *a, long start, long end);
void swap(int *a, long idx1, long idx2);
void selection_sort(int *a, long len);
\end{lstlisting}

And the error is specifically in one function. In the end, we are not a class about refactoring/debugging your code. In fact, most kernel code is so atrocious that you don't want to read it. But for the sake of debugging, it may benefit you in the long run to adopt some of these practices.

\subsection{Asserts}

Use assertions to make sure your code works up to a certain point -- and importantly, to make sure you don't break it later.
For example, if your data structure is a doubly linked list, you can do something like \texttt{assert(node == node->next->prev)} to assert that the next node has a pointer to the current node.
You can also check the pointer is pointing to an expected range of memory address, not null, -\textgreater{}size is reasonable etc.
The \texttt{NDEBUG} macro will disable all assertions, so don't forget to set that once you finish debugging. \href{http://www.cplusplus.com/reference/cassert/assert/}{assert link}

Here's a quick example with assert. Let's say that I'm writing code using memcpy

\begin{lstlisting}[language=C]
assert(!(src < dest+n && dest < src+n)); //Checks overlap
memcpy(dest, src, n);
\end{lstlisting}

This check can be turned off at compile time, but will save you \textbf{tons} of trouble debugging!

\section{Valgrind}

Valgrind is a suite of tools designed to provide debugging and profiling tools to make your programs more correct and detect some runtime issues. The most used of these tools is Memcheck, which can detect many memory-related errors that are common in C and C++ programs and that can lead to crashes and unpredictable behaviour (for example, unfreed memory buffers). To run Valgrind on your program:

\begin{lstlisting}[language=C]
valgrind --leak-check=full --show-leak-kinds=all myprogram arg1 arg2
\end{lstlisting}

Arguments are optional and the default tool that will run is Memcheck. The output will be presented in form of number of allocations, number of freed allocations, and the number of errors.Suppose we have a simple program like this:

\begin{lstlisting}[language=C]
#include <stdlib.h>

void dummy_function() {
	int* x = malloc(10 * sizeof(int));
	x[10] = 0;        // error 1:as you can see here we write to an out of bound memory address
}                    // error 2: memory leak the allocated x not freed

int main(void) {
	dummy_function();
	return 0;
}
\end{lstlisting}

This program compiles and run with no errors. Let's see what Valgrind will output.

\begin{lstlisting}[language=C]
==29515== Memcheck, a memory error detector
==29515== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==29515== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==29515== Command: ./a
==29515==
==29515== Invalid write of size 4
==29515==    at 0x400544: dummy_function (in /home/rafi/projects/exocpp/a)
==29515==    by 0x40055A: main (in /home/rafi/projects/exocpp/a)
==29515==  Address 0x5203068 is 0 bytes after a block of size 40 alloc'd
==29515==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==29515==    by 0x400537: dummy_function (in /home/rafi/projects/exocpp/a)
==29515==    by 0x40055A: main (in /home/rafi/projects/exocpp/a)
==29515==
==29515==
==29515== HEAP SUMMARY:
==29515==     in use at exit: 40 bytes in 1 blocks
==29515==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated
==29515==
==29515== LEAK SUMMARY:
==29515==    definitely lost: 40 bytes in 1 blocks
==29515==    indirectly lost: 0 bytes in 0 blocks
==29515==      possibly lost: 0 bytes in 0 blocks
==29515==    still reachable: 0 bytes in 0 blocks
==29515==         suppressed: 0 bytes in 0 blocks
==29515== Rerun with --leak-check=full to see details of leaked memory
==29515==
==29515== For counts of detected and suppressed errors, rerun with: -v
==29515== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
\end{lstlisting}

\textbf{Invalid write}: It detected our heap block overrun, writing outside of allocated block.

\textbf{Definitely lost}: Memory leak --- you probably forgot to free a memory block.

Valgrind is a very effective tool to check for errors at runtime. C is very special when it comes to such behavior, so after compiling your program you can use Valgrind to fix errors that your compiler may not catch and that usually happen when your program is running.

For more information, you can refer to the \href{http://valgrind.org/docs/manual/quick-start.html}{valgrind website}.

\subsection{TSAN}

ThreadSanitizer is a tool from Google, built into clang and gcc, to help you detect race conditions in your code. For more information about the tool, see the Github wiki. Note, that running with tsan will slow your code down a bit. Consider the following code.

\begin{lstlisting}[language=C]
#include <pthread.h>
#include <stdio.h>

int global;

void *Thread1(void *x) {
    global++;
    return NULL;
}

int main() {
    pthread_t t[2];
    pthread_create(&t[0], NULL, Thread1, NULL);
    global = 100;
    pthread_join(t[0], NULL);
}
// compile with gcc -fsanitize=thread -pie -fPIC -ltsan -g simple_race.c
\end{lstlisting}

We can see that there is a race condition on the variable \texttt{global}. Both the main thread and the thread created with \textt{pthread\_create} will try to change the value at the same time. But, does ThreadSantizer catch it?

\begin{verbatim}
$ ./a.out
==================
WARNING: ThreadSanitizer: data race (pid=28888)
  Read of size 4 at 0x7f73ed91c078 by thread T1:
    #0 Thread1 /home/zmick2/simple_race.c:7 (exe+0x000000000a50)
    #1  :0 (libtsan.so.0+0x00000001b459)

  Previous write of size 4 at 0x7f73ed91c078 by main thread:
    #0 main /home/zmick2/simple_race.c:14 (exe+0x000000000ac8)

  Thread T1 (tid=28889, running) created by main thread at:
    #0  :0 (libtsan.so.0+0x00000001f6ab)
    #1 main /home/zmick2/simple_race.c:13 (exe+0x000000000ab8)

SUMMARY: ThreadSanitizer: data race /home/zmick2/simple_race.c:7 Thread1
==================
ThreadSanitizer: reported 1 warnings
\end{verbatim}

If we compiled with the debug flag, then it would give us the variable name as well.

\section{GDB}

\href{http://www.cs.cmu.edu/~gilpin/tutorial/}{Introduction to gdb}

\paragraph{Setting breakpoints programmatically}

A very useful trick when debugging complex C programs with GDB is setting breakpoints in the source code.

\begin{lstlisting}[language=C]
int main() {
    int val = 1;
    val = 42;
    asm("int $3"); // set a breakpoint here
    val = 7;
}
\end{lstlisting}

\begin{lstlisting}[language=C]
$ gcc main.c -g -o main && ./main
(gdb) r
[...]
Program received signal SIGTRAP, Trace/breakpoint trap.
main () at main.c:6
6     val = 7;
(gdb) p val
$1 = 42
\end{lstlisting}

\paragraph{Checking memory content}

\href{http://www.delorie.com/gnu/docs/gdb/gdb\_56.html}{Memory Content}

For example,

\begin{lstlisting}[language=C]
int main() {
    char bad_string[3] = {'C', 'a', 't'};
    printf("%s", bad_string);
}
\end{lstlisting}

\begin{lstlisting}
$ gcc main.c -g -o main && ./main
$ Cat ZVQï¿½ $
\end{lstlisting}

\begin{lstlisting}
(gdb) l
1 #include <stdio.h>
2 int main() {
3     char bad_string[3] = {'C', 'a', 't'};
4     printf("%s", bad_string);
5 }
(gdb) b 4
Breakpoint 1 at 0x100000f57: file main.c, line 4.
(gdb) r
[...]
Breakpoint 1, main () at main.c:4
4     printf("%s", bad_string);
(gdb) x/16xb bad_string
0x7fff5fbff9cd: 0x63  0x61  0x74  0xe0  0xf9  0xbf  0x5f  0xff
0x7fff5fbff9d5: 0x7f  0x00  0x00  0xfd  0xb5  0x23  0x89  0xff

(gdb)
\end{lstlisting}

Here, by using the \texttt{x} command with parameters \texttt{16xb}, we can see that starting at memory address \texttt{0x7fff5fbff9c} (value of \texttt{bad\_string}), \texttt{printf} would actually see the following sequence of bytes as a string because we provided a malformed string without a null terminator.

What do you actually use to run your program? A shell! A shell is a programming language that is running inside your terminal. A terminal is merely a window to input commands. Now, on POSIX we usually have one shell called \keyword{sh} that is linked to a POSIX compliant shell called \keyword{dash}. Most of the time, you use a shell called \keyword{bash} that is not entirely POSIX compliant but has some nifty built in features. If you want to be even more advanced, \keyword{zsh} has some more powerful features like tab complete on programs and fuzzy patterns, but that is neither here nor there.

\subsection{Undefined Behavior Sanitizer}

The undefined behavior sanitizer is a wonderful tool provided by the llvm project. It allows you to compile code with a runtime checker to make sure that you don't do undefined behavior for various categories. We will try to include it into our projects, but requires support form all the external libraries that we use so we may not get around to all of them.
\url{https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html}

\subsubsection{Undefined behavior - why we can't solve it in general}

Also please please read Chris Lattner's 3 Part blog post on undefined behavior. It can shed light on debug builds and the mystery of compiler optimization.

\url{http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html}


\subsection{Clang Static Build Tools}

\subsection{strace and ltrace}

\subsection{printfs}

When all else fails, print! Each of your functions should have an idea of what it is going to do (ie find\_min better find the minimum element).
You want to test that each of your functions is doing what it set out to do and see exactly where your code breaks.
In the case with race conditions, tsan may be able to help, but having each thread print out data at certain times could help you identify the race condition.

To make printfs useful, try to have a macro that fills in the context by which the printf was called -- a log statement if you will. A simple useful but untested log statement could be as follows.
Try to make a test and figure out something that is going wrong, then log the state of your variables.

\begin{lstlisting}[language=C]
  #include <execinfo.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #include <unistd.h>

  // bt is print backtrace
  const int num_stack = 10;
  int __log(int line, const char *file, int bt, const char *fmt, ...) {
    if (bt) {
      void *raw_trace[num_stack];
      size_t size = backtrace(raw_trace, sizeof(raw_trace) / sizeof(raw_trace[0]));
      char **syms = backtrace_symbols(raw_trace, size);

      for(ssize_t i = 0; i < size; i++) {
        fprintf(stderr, "|%s:%d| %s\n", file, line, syms[i]);
      }
      free(syms);
    }
    int ret = fprintf(stderr, "|%s:%d| ", file, line);
    va_list args;
    va_start(args, fmt);
    ret += vfprintf(stderr, fmt, args);
    va_end(args);
    ret += fprintf(stderr, "\n");
    return ret;
  }

  #ifdef DEBUG
  #define log(...) __log(__LINE__, __FILE__, 0, __VA_ARGS__)
  #define bt(...) __log(__LINE__, __FILE__, 1, __VA_ARGS__)
  #else
  #define log(...)
  #define bt(...)
  #endif

  //Use as log(args like printf) or bt(args like printf) to either log or get backtrace

  int main() {
    log("Hello Log");
    bt("Hello Backtrace");
  }
\end{lstlisting}

And then use as such.

\newpage

\section{Homework 0}

\begin{lstlisting}[language=C]
// First, can you guess which lyrics have been transformed into this C-like system code?
char q[] = "Do you wanna build a C99 program?";
#define or "go debugging with gdb?"
static unsigned int i = sizeof(or) != strlen(or);
char* ptr = "lathe"; size_t come = fprintf(stdout,"%s door", ptr+2);
int away = ! (int) * "";

int* shared = mmap(NULL, sizeof(int*), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
munmap(shared,sizeof(int*));

if(!fork()) { execlp("man","man","-3","ftell", (char*)0); perror("failed"); }
if(!fork()) { execlp("make","make", "snowman", (char*)0); execlp("make","make", (char*)0)); }

exit(0);
\end{lstlisting}

\subsection{So you want to master System Programming? And get a better grade than B?}
\begin{lstlisting}[language=C]
int main(int argc, char** argv) {
	puts("Great! We have plenty of useful resources for you, but it's up to you to");
	puts(" be an active learner and learn how to solve problems and debug code.");
	puts("Bring your near-completed answers the problems below");
	puts(" to the first lab to show that you've been working on this.");
	printf("A few \"don't knows\" or \"unsure\" is fine for lab 1.\n");
	puts("Warning: you and your peers will work hard in this class.");
	puts("This is not CS225; you will be pushed much harder to");
	puts(" work things out on your own.");
	fprintf(stdout,"This homework is a stepping stone to all future assignments.\n");
	char p[] = "So, you will want to clear up any confusions or misconceptions.\n";
	write(1, p, strlen(p) );
	char buffer[1024];
	sprintf(buffer,"For grading purposes, this homework 0 will be graded as part of your lab %d work.\n", 1);
	write(1, buffer, strlen(buffer));
	printf("Press Return to continue\n");
	read(0, buffer, sizeof(buffer));
	return 0;
}
\end{lstlisting}

\subsection{Watch the videos and write up your answers to the following questions}

\textbf{Important!}

The virtual machine-in-your-browser and the videos you need for HW0 are here:

\url{http://cs-education.github.io/sys/}

Questions? Comments? Use the current semester's CS241 Piazza:
\url{https://piazza.com/}

The in-browser virtual machine runs entirely in Javascript and is fastest in Chrome. Note the VM and any code you write is reset when you reload the page, \textbf{so copy your code to a separate document.} The post-video challenges are not part of homework 0 but you learn the most by doing rather than just passively watching - so we suggest you have some fun with each end-of-video challenge.

HW0 questions are below. Copy your answers into a text document sd you'll need to submit them later in the course.

\subsection{Chapter 1}

In which our intrepid hero battles standard out, standard error, file descriptors and writing to files

\begin{enumerate}
\item \textbf{Hello, World! (system call style)} Write a program that uses \keyword{write()} to print out "Hi! My name is <Your Name>".
\item \textbf{Hello, Standard Error Stream!} Write a function to print out a triangle of height \keyword{n} to standard error.
Your function should have the signature \keyword{void write\_triangle(int n)} and should use \keyword{write()}.
The triangle should look like this, for n = 3:
\begin{lstlisting}[language=C]
*
**
***
\end{lstlisting}
\item \textbf{Writing to files} Take your program from "Hello, World!" modify it write to a file called \keyword{hello\_world.txt}. Make sure to to use correct flags and a correct mode for \keyword{open()} (\keyword{man 2 open} is your friend).
\item \textbf{Not everything is a system call} Take your program from "Writing to files" and replace \keyword{write()} with \keyword{printf()}. \textit{Make sure to print to the file instead of standard out!}
\item What are some differences between \keyword{write()} and \keyword{printf()}?
\end{enumerate}

\subsection{Chapter 2}

Sizing up C types and their limits, \keyword{int} and \keyword{char} arrays, and incrementing pointers

\begin{enumerate}
\item How many bits are there in a byte?
\item How many bytes are there in a \keyword{char}?
\item How many bytes the following are on your machine? \keyword{int}, \keyword{double}, \keyword{float}, \keyword{long}, and \keyword{long long}
\item On a machine with 8 byte integers, the declaration for the variable \keyword{data} is \keyword{int data[8]}.
If the address of data is \keyword{0x7fbd9d40}, then what is the address of \keyword{data+2}?
\item What is \keyword{data[3]} equivalent to in C? Hint: what does C convert \keyword{data[3]} to before dereferencing the address?
Remember, the type of a string constant \keyword{"abc"} is an array.
\item Why does this segfault?
\begin{lstlisting}[language=C]
char *ptr = "hello";
*ptr = 'J';
\end{lstlisting}

\item What is the value of the variable \keyword{str\_size}?
\begin{lstlisting}[language=C]
ssize_t str_size = sizeof("Hello\0World")
\end{lstlisting}
\item What is the value of the variable \keyword{str\_len}
\begin{lstlisting}[language=C]
ssize_t str_len = strlen("Hello\0World")
\end{lstlisting}
\item Give an example of X such that \keyword{sizeof(X)} is 3.
\item Give an example of Y such that \keyword{sizeof(Y)} might be 4 or 8 depending on the machine.
\end{enumerate}

\subsection{Chapter 3}

Program arguments, environment variables, and working with character arrays (strings)

\begin{enumerate}
\item What are two ways to find the length of \keyword{argv}?
\item What does \keyword{argv[0]} represent?
\item Where are the pointers to environment variables stored (on the stack, the heap, somewhere else)?
\item On a machine where pointers are 8 bytes, and with the following code:
\begin{lstlisting}[language=C]
char *ptr = "Hello";
char array[] = "Hello";
\end{lstlisting}
What are the values of \keyword{sizeof(ptr)} and \keyword{sizeof(array)}? Why?
\item What data structure manages the lifetime of automatic variables?
\end{enumerate}

\subsection{Chapter 4}

Heap and stack memory, and working with structs

\begin{enumerate}
\item If I want to use data after the lifetime of the function it was created in ends, where should I put it? How do I put it there?
\item What are the differences between heap and stack memory?
\item Are there other kinds of memory in a process?
\item Fill in the blank: "In a good C program, for every malloc, there is a \_\_\_".
\item What is one reason \keyword{malloc} can fail?
\item What are some differences between \keyword{time()} and \keyword{ctime()}?
\item What is wrong with this code snippet?
\begin{lstlisting}[language=C]
free(ptr);
free(ptr);
\end{lstlisting}
\item What is wrong with this code snippet?
\begin{lstlisting}[language=C]
free(ptr);
printf("%s\n", ptr);
\end{lstlisting}
\item How can one avoid the previous two mistakes?
\item Create a \keyword{struct} that represents a \keyword{Person}.
  Then make a \keyword{typedef}, so that \keyword{struct Person} can be replaced with a single word.
  A person should contain the following information: their name (a string), their age (an integer), and a list of their friends (stored as a pointer to an array of pointers to \keyword{Person}s).
\item Now, make two persons on the heap, "Agent Smith" and "Sonny Moore", who are 128 and 256 years old respectively and are friends with each other.
Create functions to create and destroy a Person (Person's and their names should live on the heap).
\item \keyword{create()} should take a name and age.
  The name should be copied onto the heap.
  Use malloc to reserve sufficient memory for everyone having up to ten friends.
  Be sure initialize all fields (why?).
\item \keyword{destroy()} should free up not only the memory of the person struct, but also free all of its attributes that are stored on the heap. Destroying one person should not destroy any others.
\end{enumerate}

\subsection{Chapter 5}

Text input and output and parsing using \keyword{getchar}, \keyword{gets}, and \keyword{getline}.

\begin{enumerate}
\item What functions can be used for getting characters from \keyword{stdin} and writing them to \keyword{stdout}?
\item Name one issue with \keyword{gets()}.
\item Write code that parses the string "Hello 5 World" and initializes 3 variables to "Hello", 5, and "World".
\item What does one need to define before including \keyword{getline()}?
\item Write a C program to print out the content of a file line-by-line using \keyword{getline()}.
\end{enumerate}

\subsection{C Development}

These are general tips for compiling and developing using a compiler and git.
Some web searches will be useful here

\begin{enumerate}
\item What compiler flag is used to generate a debug build?
\item You fix a problem in the Makefile and type \keyword{make} again.
Explain why this may be insufficient to generate a new build.
\item Are tabs or spaces used to indent the commands after the rule in a Makefile?
\item What does \keyword{git commit} do? What's a \keyword{sha} in the context of git?
\item What does \keyword{git log} show you?
\item What does \keyword{git status} tell you and how would the contents of \keyword{.gitignore} change its output?
\item What does \keyword{git push} do? Why is it not just sufficient to commit with \keyword{git commit -m 'fixed all bugs' }?
\item What does a non-fast-forward error \keyword{git push} reject mean? What is the most common way of dealing with this?
\end{enumerate}

\subsection{Optional: Just for fun}

\begin{itemize}
\item Convert your a song lyrics into System Programming and C code covered in this wiki book and share on Piazza.
\item Find, in your opinion, the best and worst C code on the web and post the link to Piazza.
\item Write a short C program with a deliberate subtle C bug and post it on Piazza to see if others can spot your bug.
\item Do you have any cool/disastrous system programming bugs you've heard about? Feel free to share with your peers and the course staff on piazza.
\end{itemize}

\section{UIUC Specific Guidelines}

\subsection{Piazza}

TAs and student assistants get a ton of questions.
Some are well-researched, and some...are not.
This is a handy guide that'll help you move away from the latter and towards the former.
Oh, and did I mention that this is an easy way to score points with your internship managers? Ask yourself...

\begin{enumerate}
\item Am I running on EWS?
\item \textbf{Did I check the man pages?}
\item Have I searched for similar questions/followups on Piazza?
\item Have I read the MP/DS specification completely?
\item Have I watched all of the videos?
\item Did I Google the error message and a few permutations thereof if necessary?
\item Did I try commenting out, printlining, and/or stepping through parts of the code bit by bit to find out precisely where the error occurs?
\item \textbf{Did I commit my code to git in case the TAs need more context?}
\item Did I include the console/GDB/Valgrind output **AND** code surrounding the bug in my Piazza post?
\item Have I fixed other segmentation faults not related to the issue I'm having?
\item Am I following good programming practice? (i.e. encapsulation, functions to limit repetition, etc)
\end{enumerate}
